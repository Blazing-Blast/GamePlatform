# 0 "src/common/graphics/basic.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "src/common/graphics/basic.cpp"
# 1 "src/common/graphics/basic.hpp" 1
# 1 "src/common/graphics/../types/types.hpp" 1



typedef unsigned long long u64;
typedef unsigned long int u32;
typedef unsigned short u16;
typedef unsigned char u8;

typedef signed long long i64;
typedef signed long i32;
typedef signed short i16;
typedef signed char i8;

typedef struct Colour {
    u32 c;
} Colour;

typedef struct ARGB {
    u8 a;
    u8 r;
    u8 g;
    u8 b;
} ARGB;

typedef struct Point2D {
    u32 x;
    u32 y;
} Point2D;

typedef struct Colour2D {
    Point2D pos;
    Colour col;
} Colour2D;

typedef struct SizedBuffer {
    Colour *buffer;
    u32 width;
    u32 height;
} SizedBuffer;
# 2 "src/common/graphics/basic.hpp" 2

namespace Graphics {
    void SetPixel (SizedBuffer *buffer, const Colour2D &colour);
    Colour GetPixel (SizedBuffer *buffer, const Point2D pos);
    u8 InitPixel (SizedBuffer *buffer, const Colour2D &colour, const Colour reference);
    void DrawRect (SizedBuffer *buffer, const Colour2D &colour, Point2D size);
    void DrawCircle (SizedBuffer *buffer, const Colour2D &colour, u32 radius);


}
# 2 "src/common/graphics/basic.cpp" 2


void Graphics::SetPixel(SizedBuffer *buffer, const Colour2D &colour) {
    if (colour.pos.x >= buffer->width || colour.pos.y >= buffer->height) return;
    buffer->buffer[colour.pos.y * buffer->width + colour.pos.x] = colour.col;
}

Colour Graphics::GetPixel(SizedBuffer *buffer, const Point2D pos) {
    if (pos.x >= buffer->width || pos.y >= buffer->height) return {0};
    return {buffer->buffer[pos.y * buffer->width + pos.x].c & 0x00FFFFFF};
}

u8 Graphics::InitPixel(SizedBuffer *buffer, const Colour2D &colour, const Colour reference) {
    if (colour.pos.x >= buffer->width || colour.pos.y >= buffer->height) return 0;
    if (Graphics::GetPixel(buffer, colour.pos).c != reference.c) return 0;
    Graphics::SetPixel(buffer, colour);
    return 1;
}

void Graphics::DrawRect(SizedBuffer *buffer, const Colour2D &colour, Point2D size) {
    for (u32 y = colour.pos.y; y < size.y + colour.pos.y; y++) {
        for (u32 x = colour.pos.x; x < size.x + colour.pos.x; x++) {
            Colour2D pixel = {.pos = Point2D{.x = x, .y = y}, .col = colour.col};
            SetPixel(buffer, pixel);
        }
    }
}

void Graphics::DrawCircle(SizedBuffer *buffer, const Colour2D &colour, u32 radius) {
    for (i32 y = -radius; y < (i32)radius; y++) {
        if((i32)colour.pos.y + y < 0) continue;
        for (i32 x = -radius; x < (i32)radius; x++) {
            if((i32)colour.pos.x + x < 0) continue;
            if (y*y + x*x <= (i32)(radius*radius)) {
                Colour2D pixel = {.pos = Point2D{.x = (u32)x + colour.pos.x, .y = (u32)y + colour.pos.y}, .col = colour.col};
                SetPixel(buffer, pixel);
            }
        }
    }
}
